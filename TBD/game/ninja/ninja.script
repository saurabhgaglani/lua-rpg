local MAX_GROUND_SPEED = 50
-- max fall speed

-- gravity pulling the player down in pixel units
local GRAVITY = -500

-- push-back when shooting
local RECOIL = 500

-- pre-hashing ids improves performance
local CONTACT_POINT_RESPONSE = hash("contact_point_response")
local TRIGGER_RESPONSE = hash("trigger_response")
local GROUND = hash("ground")
local WALL = hash("walls")
local ENEMY = hash("enemy")
local END_OF_LEVEL = hash("endoflevel")


function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	self.velocity = vmath.vector3(0,0,0)
	self.movement = 1
	self.anim = nil

	self.ground_contact = true
	-- also track state of last frame
	-- (to detect when landing or taking off)
	self.previous_ground_contact = true

	self.start_time = socket.gettime()
	self.time_elapsed = 0.0
	self.time_set = false
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function play_animation(self, anim)
	if self.anim ~= anim then
		msg.post("#enemy", "play_animation", {id = anim})
		self.anim = anim
	end
end

local function update_animations(self)
	-- make sure the player character faces the right way
	sprite.set_hflip("#enemy", self.movement<0)
end

-- clamp a number between a min and max value
local function clamp(v, min, max)
	if v < min then return min
	elseif v > max then return max
	else return v end
end

-- apply an opposing force to decrease a velocity
local function decelerate(v, f, dt)
	local opposing = math.abs(v * f)
	if v > 0 then
		return math.floor(math.max(0, v - opposing * dt))
	elseif v < 0 then
		return math.ceil(math.min(0, v + opposing * dt))
	else
		return 0
	end
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	local target_speed = self.movement* MAX_GROUND_SPEED
	local speed_diff = target_speed - self.velocity.x
	local acceleration = vmath.vector3(0, GRAVITY, 0)

	if(speed_diff ~= 0) then
		if(speed_diff < 0) then
			acceleration.x = - MAX_GROUND_SPEED
		else
			acceleration.x = MAX_GROUND_SPEED
		end
	end

	local dv = acceleration*dt
	if(math.abs(dv.x)>math.abs(speed_diff)) then
		dv.x = speed_diff
	end

	local v0 = self.velocity
	self.velocity = self.velocity + dv

	local dp = (v0+ self.velocity)*dt

	update_animations(self)
	go.set_position(go.get_position() + dp)

	self.correction = vmath.vector3()

	self.ground_contact = false
	self.wall_contact = false;
end

function fixed_update(self, dt)
	-- This function is only called if 'Use Fixed Timestep' is enabled in the Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function handle_obstacle_contact(self, normal, distance)
	if distance > 0 then
		-- First, project the accumulated correction onto
		-- the penetration vector
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			-- Only care for projections that does not overshoot.
			local comp = (distance - distance * proj) * normal
			-- Apply compensation
			go.set_position(go.get_position() + comp)
			-- Accumulate correction done
			self.correction = self.correction + comp
		end
	end

	-- -- collided with a wall
	-- -- stop horizontal movement
	-- if math.abs(normal.x) > 0.7 then
	-- 	self.wall_contact = true
	-- 	self.velocity.x = 0
	-- end
	
	-- collided with the ground
	-- stop vertical movement
	if normal.y > 0.7 then
		self.ground_contact = true
		self.velocity.y = 0
	end
end

local function handle_wall_contact(self, normal, distance)
	local proj = vmath.dot(self.correction, normal)
	local comp = (distance-proj)*normal

	self.correction = self.correction+comp
	go.set_position(go.get_position()+comp)

	if normal.x ~= 0 then
		self.wall_contact = true
		self.movement = self.movement*(-1)
	end

	proj = vmath.dot(self.velocity, normal)
	if proj < 0 then
		self.velocity = self.velocity - proj*normal
	end
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
	if message_id == CONTACT_POINT_RESPONSE then
		-- check that the object is something we consider an obstacle
		if message.group == GROUND then
			handle_obstacle_contact(self, message.normal, message.distance)
		elseif message.group == WALL and not self.wall_contact then
			handle_wall_contact(self, message.normal, message.distance)
		end
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
